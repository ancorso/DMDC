diff --git a/pyfr/plugins/controller.py b/pyfr/plugins/controller.py
index 5f5b880..1e67bc2 100644
--- a/pyfr/plugins/controller.py
+++ b/pyfr/plugins/controller.py
@@ -64,6 +64,10 @@ def _closest_upts(etypes, eupts, pts):
         # Otherwise fall back to brute force
         yield from _closest_upts_bf(etypes, eupts, pts)
 
+class FillerArgs:
+    code_dim = -1
+    action_dim = -1
+
 
 class ControllerPlugin(BasePlugin):
     name = 'controller'
@@ -81,6 +85,9 @@ class ControllerPlugin(BasePlugin):
         self.save_data = self.cfg.getint(cfgsect, 'savedata')
         self.set_omega = self.cfg.getint(cfgsect, 'setomega')
         self.perform_mpc = (self.cfg.getint(cfgsect, 'mpc') == 1)
+        self.perform_dmdc = (self.cfg.getint(cfgsect, 'dmdc') == 1)
+        self.perform_online_dmdc = (self.cfg.getint(cfgsect, 'online_dmdc') == 1)
+
 
         # List of points to be sampled and format
         self.pts = self.cfg.getliteral(cfgsect, 'samp-pts')
@@ -89,6 +96,54 @@ class ControllerPlugin(BasePlugin):
         # Define directory where solution snapshots should be saved
         self.save_dir = self.cfg.getpath(cfgsect, 'save_dir')
 
+        # If performing dmdc, load matrices
+        if self.perform_dmdc:
+            # Set constraints for mpc
+            self.R = self.cfg.getfloat(cfgsect, 'R')
+            self.u_max = self.cfg.getfloat(cfgsect, 'u_max')
+
+            # Load desired attributes from file
+            f = h5py.File('./A_B_Uhat.h5', 'r')
+            self.A = np.array(f['A']).T
+            self.B = np.array(f['B']).T
+            self.U_hat_t = np.array(f['U_hat']).T
+            self.args = FillerArgs()
+            self.args.code_dim = np.size(self.U_hat_t, 0)
+            self.args.action_dim = np.size(self.B, 1)
+
+            f = h5py.File(self.cfg.getpath(cfgsect, 'base_flow'), 'r')
+            self.goal_state = self.U_hat_t @ np.array(f['sol_data']).flatten()
+
+        # If performing mpc, then load network
+        if self.perform_online_dmdc:
+            # set sequence length and get path to julia code for computing dmdc
+            self.dmdc_seq_len = self.cfg.getint(cfgsect, 'dmdc_seq_len')
+            self.dmdc_train_path = self.cfg.getpath(cfgsect, 'dmdc_train_path')
+            sys.path.append(self.dmdc_train_path)
+
+            # Store untransformed base flow data
+            f = h5py.File(self.cfg.getpath(cfgsect, 'base_flow'), 'r')
+            self.raw_goal_state = np.array(f['sol_data']).flatten()
+
+            # Set constraints for mpc
+            self.R = self.cfg.getfloat(cfgsect, 'R')
+            self.u_max = self.cfg.getfloat(cfgsect, 'u_max')
+
+            # Load starting dynamics
+            f = h5py.File('./A_B_Uhat.h5', 'r')
+            self.A = np.array(f['A']).T
+            self.B = np.array(f['B']).T
+            self.U_hat_t = np.array(f['U_hat']).T
+            self.args = FillerArgs()
+            self.args.code_dim = np.size(self.U_hat_t, 0)
+            self.args.action_dim = np.size(self.B, 1)
+
+            # Define array to hold old time snapshots and control inputs of the system
+            self.X = np.zeros((self.dmdc_seq_len + 1, 128, 256, 4), dtype=np.float32)
+            self.u = np.zeros((self.dmdc_seq_len, self.args.action_dim), dtype=np.float32)
+
+            print("Constructed X", self.X.shape, "and u", self.u.shape, "history vectors")
+
         # If performing mpc, then load network
         if self.perform_mpc:
 
@@ -195,6 +250,29 @@ class ControllerPlugin(BasePlugin):
 
         return A, x0
 
+    # Find A-matrix and initial code value from neural network
+    def _find_dmdc_dynamics(self):
+        print("finding dmdc dynamics...")
+
+        # Save X and u to file
+        f = h5py.File('./X_u.h5', 'w')
+        f['X'] = self.X
+        f['u'] = self.u
+        f.close()
+
+        # Run python script to find A matrix and initial state
+        command = "julia " + self.dmdc_train_path + "/find_dynamics.jl "
+        subprocess.call(command.split())
+
+        # Load desired values from file and return
+        f = h5py.File('A_B_Uhat.h5', 'r')
+        A = np.array(f['A']).T
+        B = np.array(f['B']).T
+        U_hat_t = np.array(f['U_hat']).T
+        print("done")
+
+        return A, B, U_hat_t
+
     # Perform MPC optimization to find next input
     # Following example from CVXPY documentation
     def _find_mpc_input(self, A, B, x0):
@@ -214,14 +292,14 @@ class ControllerPlugin(BasePlugin):
         constr = []
         for t in range(T):
             cost += quad_form((x[:,t+1] - self.goal_state), Q) + quad_form(u[:,t], R)
-            constr += [x[:,t+1] == A*x[:,t] + (B*u[:,t])[:,0],
+            constr += [x[:,t+1] == A*x[:,t] + B*u[:,t],
                         norm(u[:,t], 'inf') <= self.u_max]
 
         # Sum problem objectives and concatenate constraints
         constr += [x[:,0] == x0]
         prob = Problem(Minimize(cost),constr)
         prob.solve()
-        
+
         x1 = np.array([x.value[i, 1] for i in range(x.value.shape[0])])
         try:
             return u.value[0, 0] # Change if not scalar input
@@ -292,7 +370,8 @@ class ControllerPlugin(BasePlugin):
                 sol_data[idx1, idx2] = data[i][1]
 
             # Update running total of previous states
-            if self.perform_mpc: self.X = np.vstack((self.X[1:], np.expand_dims(sol_data, axis=0)))
+            if self.perform_mpc or self.perform_online_dmdc:
+                self.X = np.vstack((self.X[1:], np.expand_dims(sol_data, axis=0)))
 
             # Initialize values
             t = intg.tcurr
@@ -301,6 +380,23 @@ class ControllerPlugin(BasePlugin):
 
             if self.set_omega == 0:
                 omega = 0.0
+            elif self.perform_dmdc:
+                x0 = self.U_hat_t @ sol_data.flatten()
+                omega = self._find_mpc_input(self.A, self.B, x0)
+            elif self.perform_online_dmdc:
+                # If we have seen enough input, update, A, B and U_hat_t
+                if np.linalg.norm(self.X[0]) > 0.0:
+                    self.A, self.B, self.U_hat_t = self._find_dmdc_dynamics()
+
+                print('Running MPC to get optimal omega from dmdc dynamics...')
+                # Transform the current state and goal state based on the tranform corresponding to A
+                x0 = self.U_hat_t @ sol_data.flatten()
+                self.goal_state = self.U_hat_t @ self.raw_goal_state
+
+                # Find the optimal control input
+                omega = self._find_mpc_input(self.A, self.B, x0)
+                print('Optimal omega: ', omega)
+                self.u = np.concatenate((self.u[1:], np.expand_dims(np.array([omega]), axis=0)))
             elif self.perform_mpc:
                 # Find model of system and determine optimal input with MPC
                 try:
@@ -340,7 +436,8 @@ class ControllerPlugin(BasePlugin):
                 f = h5py.File(filename, 'w')
                 f['sol_data'] = sol_data
                 f['control_input'] = omega
-                if self.perform_mpc: f['cost'] = np.linalg.norm(self.goal_state - x0)
+                if self.perform_mpc or self.perform_dmdc or self.perform_online_dmdc:
+                    f['cost'] = np.linalg.norm(self.goal_state - x0)
                 f.close()
         else:
             omega = None
